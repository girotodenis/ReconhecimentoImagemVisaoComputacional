# -*- coding: utf-8 -*-
"""Atividade 1 - Parte A.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aw7rOYUVeRGxybj2DQ2_KT4ulPnFLb_e

##Configurações
"""

# Commented out IPython magic to ensure Python compatibility.
from google.colab.patches import cv2_imshow
# %matplotlib inline
from matplotlib import pyplot as plt
import cv2
import os
import numpy as np

from google.colab import drive
drive.mount('/content/gdrive')
PATH_IMAGENS = "/content/gdrive/My Drive/Estudos/Pós graduação/Inteligência Artificial/Reconhecimento de Imagem e Visão computacional/Atividade 1/imagens/"

"""##Exercício 1

###(a) Crie uma função (em Python) que seja capaz de reduzir e/ou aumentar a resolução espacial de uma imagem por um fator n, que é um número real positivo (n>1 para um aumento da resolução espacial e n< 1 para uma redução da resolução espacial). Tal função deve possuir como parâmetros de entrada, o nome do arquivo da imagem para leitua no disco e o fator n. Para aumento da resolução utilize a técnica do vizinho-mais-próximo vista em sala de aula.
"""

def resolucao(nome, fator_n):
  imagem = cv2.imread(PATH_IMAGENS + nome)
  # print(imagem)

  if fator_n == 0:
    return imagem
  elif fator_n < 1:
    return imagem[::abs(fator_n),::abs(fator_n)]
  else:
    return np.repeat( np.repeat(imagem, fator_n, axis=0) , fator_n, axis=1)

img = resolucao('lenna.png', -64)
# cv2_imshow(img)
print(type(img[0]))

# num_linhas = len(img)
# num_colunas = len(img[0])
# num_
# for linha in img:
#   # print("linha: " + str(len(linha)) + " pixels")
#   for pixels in linha:
#     # print("pixels" + str(pixels))
#     for x in pixels:
#       x = 0
# cv2_imshow(img)

colors = [[0, 0, 0], [255, 255, 255]]

class Cycle:
  index_atual = None
  objs = None

  def __init__(self, objs):
    self.objs = objs
    self.index_atual = 0

  def next(self):
    size = len(self.objs)
    if self.index_atual == size:
      self.index_atual = 0
    index = self.index_atual
    self.index_atual += 1
    return self.objs[index]


def criar_imagem(height, width, colors, blocksize = 10):
  colors = Cycle(colors)
  img = []
  for row in range(height):
    row = []
    for col in range(width):
      color = colors.next()
      row.append(np.array(color))
    img.append(np.array(row))
  return np.array(img)

img = criar_imagem(200, 199, colors)
# print(img)
cv2_imshow(img)

"""###(b) Utilize o sua função do item anterior para gerar imagens com resolução espacial reduzida por fatores de 2, 4, 8 e 16. Em seguida, utilize o seu programa novamente para aumentar estas imagens de volta ao seu tamanho original. Há diferenças de qualidade entre estas imagens? Comente. (Obs.: Plote os resultados para que possam se visualizados)."""

img = resolucao('lenna.png', -2)
cv2.imwrite(PATH_IMAGENS + "lenna_2menos.png", img) 
cv2_imshow(img)  
img = resolucao('lenna.png', -4)
cv2.imwrite(PATH_IMAGENS + "lenna_4menos.png", img)  
cv2_imshow(img) 
img = resolucao('lenna.png', -8)
cv2.imwrite(PATH_IMAGENS + "lenna_8menos.png", img)  
cv2_imshow(img) 
img = resolucao('lenna.png', -16)
cv2.imwrite(PATH_IMAGENS + "lenna_16menos.png", img)
cv2_imshow(img)

img = resolucao('lenna_2menos.png', 2)
cv2_imshow(img)  
img = resolucao('lenna_4menos.png', 4)
cv2_imshow(img) 
img = resolucao('lenna_8menos.png', 8)
cv2_imshow(img) 
img = resolucao('lenna_16menos.png', 16)
cv2_imshow(img)

"""###(c) Modifique a função desenvolvida em (a), de forma que seja utilizada a técnica de interpolação bilinear e refaça o que se pede no item (b) novamente. (Obs.: Plote os resultados para que possam se visualizados)."""

import numpy as np
from scipy import ndimage
from math import floor, ceil
 
def bilinear_pixel(imArr, posX, posY):
    out = []
    
    modXi = int(posX)
    modYi = int(posY)
    modXiPlusOneLim=min(modXi+1,imArr.shape[1]-1)
    modYiPlusOneLim=min(modYi+1,imArr.shape[0]-1)

    dx = posX-modXi
    dy = posY-modYi

    for chan in range(imArr.shape[2]):
        a = imArr[modYi,modXi,chan]
        b = imArr[modYi,modXiPlusOneLim,chan]
        c = imArr[modYiPlusOneLim,modXi,chan]
        d = imArr[modYiPlusOneLim,modXiPlusOneLim,chan]
        
        res = (1-dx)*(1-dy)*a+dx*(1-dy)*b+(1-dx)*dy*c+dx*dy*d
        out.append(int(res))

    return out
 

def resolucao_bilinear(nome, fator_n):  
  im = cv2.imread(PATH_IMAGENS + nome)

  #Aumentando ou diminuindo o Array(resize)
  if fator_n == 0:
    return im
  elif fator_n < 0:
    fator_n *= -1
    resizedShape = list(map(int, [im.shape[0] / fator_n, im.shape[1] / fator_n, im.shape[2]]))
  else:
    resizedShape = list(map(int, [im.shape[0] * fator_n, im.shape[1] * fator_n, im.shape[2]]))

  resizedImg = np.empty(resizedShape, dtype=np.uint8)
  rowScale = float(im.shape[0]) / float(resizedImg.shape[0])
  colScale = float(im.shape[1]) / float(resizedImg.shape[1])

  for row in range(resizedImg.shape[0]):
    for col in range(resizedImg.shape[1]):
      row_original = row * rowScale
      col_original = col * colScale
      resizedImg[row, col] = bilinear_pixel(im, col_original, row_original)

  return resizedImg

img = resolucao_bilinear('lenna.png', -2)
cv2.imwrite(PATH_IMAGENS + "lenna_2menos.png", img) 
cv2_imshow(img)  
img = resolucao_bilinear('lenna.png', -4)
cv2.imwrite(PATH_IMAGENS + "lenna_4menos.png", img)  
cv2_imshow(img) 
img = resolucao_bilinear('lenna.png', -8)
cv2.imwrite(PATH_IMAGENS + "lenna_8menos.png", img)  
cv2_imshow(img) 
img = resolucao_bilinear('lenna.png', -16)
cv2.imwrite(PATH_IMAGENS + "lenna_16menos.png", img)
cv2_imshow(img)

img = resolucao_bilinear('lenna_2menos.png', 2)
cv2_imshow(img)  
img = resolucao_bilinear('lenna_4menos.png', 4)
cv2_imshow(img) 
img = resolucao_bilinear('lenna_8menos.png', 8)
cv2_imshow(img) 
img = resolucao_bilinear('lenna_16menos.png', 16)
cv2_imshow(img)